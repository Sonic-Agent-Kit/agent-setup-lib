"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentSetup = exports.AgentState = void 0;
const zod_1 = require("zod");
const messages_1 = require("@langchain/core/messages");
const langgraph_1 = require("@langchain/langgraph");
const prompts_1 = require("@langchain/core/prompts");
const output_parsers_1 = require("langchain/output_parsers");
const supervisor_1 = require("./prompts/supervisor");
// Define the state schema for the DeFi trading team.
exports.AgentState = langgraph_1.Annotation.Root({
    messages: (0, langgraph_1.Annotation)({
        reducer: (x, y) => x.concat(y),
    }),
    team_members: (0, langgraph_1.Annotation)({
        reducer: (x, y) => x.concat(y),
    }),
    next: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
        default: () => "supervisor",
    }),
    instructions: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
        default: () => "Select the correct team member for the task",
    }),
    stateOption: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
    }),
});
class AgentSetup {
    constructor(state, llm) {
        this.state = state;
        this.llm = llm;
    }
    /**
     * Returns a string that modifies the agent's state based on the conversation history.
     *
     * @param systemPrompt - The system prompt.
     * @param tools - The list of available tools.
     * @param teamMembers - The list of team member names.
     * @returns A string that is the modified state.
     */
    agentStateModifier(systemPrompt, tools, teamMembers) {
        const toolNames = tools.map((t) => t.name).join(", ");
        const systemMsgStart = new messages_1.SystemMessage(systemPrompt +
            "\nWork autonomously according to your specialty, using the tools available to you." +
            " Do not ask for clarification." +
            " Your other team members (and other teams) will collaborate with you with their own specialties." +
            ` You are chosen for a reason! You are one of the following team members: ${teamMembers.join(", ")}.`);
        const systemMsgEnd = new messages_1.SystemMessage(`Supervisor instructions: ${systemPrompt}\n` +
            `Remember, you individually can only use these tools: ${toolNames}` +
            "\n\nEnd if you have already completed the requested task. Communicate the work completed.");
        const stateModifier = (state) => {
            const messages = state.messages.map((msg, index) => `"Message ${index + 1}": ${msg.content}`);
            return [
                `"System Message Start": ${systemMsgStart.content}`,
                ...messages,
                `"System Message End": ${systemMsgEnd.content}`,
            ].join("\n");
        };
        return stateModifier;
    }
    /**
    * Returns a string that modifies the agent's state based on the conversation history.
    *
    * @param systemPrompt - The system prompt.
    * @param tools - The list of available tools.
    * @returns A string that is the modified state.
    */
    agentStateModifierV2(systemPrompt, tools) {
        const toolNames = tools.map((t) => t.name).join(", ");
        const systemMsgStart = new messages_1.SystemMessage(systemPrompt +
            "\nWork autonomously according to your specialty, using the tools available to you." +
            " Do not ask for clarification." +
            ` You are chosen for a reason!.`);
        const systemMsgEnd = new messages_1.SystemMessage(`instructions: ${systemPrompt}\n` +
            `Remember, you individually can only use these tools: ${toolNames}` +
            "\n\nEnd if you have already completed the requested task. Communicate the work completed.");
        const stateModifier = (state) => {
            const messages = state.messages.map((msg, index) => `"Message ${index + 1}": ${msg.content}`);
            return [
                `"System Message Start": ${systemMsgStart.content}`,
                ...messages,
                `"System Message End": ${systemMsgEnd.content}`,
            ].join("\n");
        };
        return stateModifier;
    }
    /**
     * Invokes an agent node and returns a new HumanMessage based on the agent's last message.
     *
     * @param params - An object containing the agent (Runnable) and the name.
     * @returns An object with a `messages` property containing the HumanMessage.
     */
    async runAgentNode(params) {
        const { state, agent, name } = params;
        const result = await agent.invoke({
            messages: state.messages,
        });
        const lastMessage = result.messages[result.messages.length - 1];
        return {
            messages: [new messages_1.HumanMessage({ content: lastMessage.content, name })],
        };
    }
    /**
     * Creates a team supervisor runnable that selects the next role.
     *
     * @param members - The list of team member names and their classification if any.
     * @returns A Promise resolving to a Runnable that selects the next role.
     */
    async createTeamSupervisor(members, system_prompt) {
        const membersName = members.map(x => x.name);
        const options = ["FINISH", ...membersName];
        const routeTool = {
            name: "route",
            description: "Select the next role.",
            schema: zod_1.z.object({
                reasoning: zod_1.z.string(),
                next: zod_1.z.enum(["FINISH", ...membersName]),
                instructions: zod_1.z
                    .string()
                    .describe("The specific instructions of the sub-task the next role should accomplish."),
            }),
        };
        const _systemPrompt = await (0, supervisor_1.superviso_prompt)(members, system_prompt);
        let prompt = prompts_1.ChatPromptTemplate.fromMessages([
            ["system", _systemPrompt],
            new prompts_1.MessagesPlaceholder("messages"),
            [
                "system",
                `Given the conversation above, who should act next? Or should we FINISH? Select one of: ${options}`,
            ],
        ]);
        prompt = await prompt.partial({
            team_members: membersName.join(", "),
        });
        const supervisor = prompt
            .pipe(this.llm.bindTools([routeTool], {
            tool_choice: "route",
        }))
            .pipe(new output_parsers_1.JsonOutputToolsParser())
            // select the first one
            .pipe((x) => ({
            next: x[0].args.next,
            instructions: x[0].args.instructions,
        }));
        return supervisor;
    }
}
exports.AgentSetup = AgentSetup;
