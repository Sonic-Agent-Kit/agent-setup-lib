"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentTaskScheduler = void 0;
// src/AgentTaskScheduler.ts
const uuid_1 = require("uuid");
class AgentTaskScheduler {
    constructor(config, taskRepository, rabbitMQService) {
        this.config = config;
        this.taskRepository = taskRepository;
        this.rabbitMQService = rabbitMQService;
        // Replace cron with setInterval to allow for more frequent checks
        // config.checkIntervalMs should be set to the desired interval in milliseconds (e.g., 1000 for 1 second)
        this.checkInterval = setInterval(() => {
            this.checkDueTasks();
        }, this.config.checkIntervalMs);
    }
    // Method to stop the interval when needed (e.g., during shutdown)
    stop() {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
        }
    }
    async scheduleTask(agentId, userId, taskQuery, taskDescription, scheduledTime, recurrenceInterval, recurrenceEndTime) {
        const id = (0, uuid_1.v4)();
        const task = {
            id,
            userId,
            agentId,
            taskQuery,
            taskDescription,
            scheduledTime,
            status: "pending",
            recurrenceInterval,
            recurrenceEndTime,
        };
        await this.taskRepository.saveTask(task);
        return id;
    }
    async checkDueTasks() {
        const now = new Date();
        const dueTasks = await this.taskRepository.getDueTasks(now);
        for (const task of dueTasks) {
            //console.log(`Task ${task.id} is due. Publishing to queue...`);
            task.status = "queued";
            await this.taskRepository.saveTask(task); // update status
            await this.rabbitMQService.publishTask(task);
            // If the task is recurring, update its scheduledTime.
            if (task.recurrenceInterval) {
                const nextTime = new Date(task.scheduledTime.getTime() + task.recurrenceInterval);
                if (task.recurrenceEndTime && nextTime.getTime() > task.recurrenceEndTime.getTime()) {
                    //console.log(`Task ${task.id} recurrence ended.`);
                    await this.taskRepository.removeTask(task.id);
                }
                else {
                    task.scheduledTime = nextTime;
                    task.status = "pending";
                    await this.taskRepository.saveTask(task);
                    //console.log(`Task ${task.id} rescheduled for ${nextTime.toISOString()}`);
                }
            }
            else {
                await this.taskRepository.removeTask(task.id);
            }
        }
    }
    async cancelTask(taskId) {
        await this.taskRepository.removeTask(taskId);
        //console.log(`Cancelled task ${taskId}`);
        return true;
    }
}
exports.AgentTaskScheduler = AgentTaskScheduler;
