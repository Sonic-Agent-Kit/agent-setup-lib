"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.taskRepository = exports.TaskRepository = void 0;
class TaskRepository {
    constructor(redisClient) {
        this.redisClient = redisClient;
    }
    async saveTask(task) {
        const key = `task:${task.id}`;
        await this.redisClient.client.set(key, JSON.stringify(task));
        await this.redisClient.client.zadd("tasks:pending", task.scheduledTime.getTime().toString(), task.id);
    }
    async removeTask(taskId) {
        const key = `task:${taskId}`;
        await this.redisClient.client.del(key);
        await this.redisClient.client.zrem("tasks:pending", taskId);
    }
    async getDueTasks(currentTime) {
        const maxScore = currentTime.getTime();
        const taskIds = await this.redisClient.client.zrangebyscore("tasks:pending", "0", maxScore.toString());
        const tasks = [];
        for (const id of taskIds) {
            const key = `task:${id}`;
            const taskJson = await this.redisClient.client.get(key);
            if (taskJson) {
                const taskObj = JSON.parse(taskJson);
                taskObj.scheduledTime = new Date(taskObj.scheduledTime);
                // Convert recurrenceEndTime if it exists.
                if (taskObj.recurrenceEndTime) {
                    taskObj.recurrenceEndTime = new Date(taskObj.recurrenceEndTime);
                }
                tasks.push(taskObj);
            }
        }
        return tasks;
    }
}
exports.TaskRepository = TaskRepository;
exports.taskRepository = new TaskRepository(new (require("./RedisClient").RedisClient)(require("./Config").config));
