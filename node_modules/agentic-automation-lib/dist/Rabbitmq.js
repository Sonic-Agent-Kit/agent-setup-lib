"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RabbitMQService = void 0;
// src/RabbitMQService.ts
const amqplib_1 = __importDefault(require("amqplib"));
const QUEUE_NAME = "agentTaskQueue";
class RabbitMQService {
    constructor(config, queueName) {
        this.config = config;
        this.queueName = queueName ? queueName : QUEUE_NAME;
    }
    async init() {
        this.connection = await amqplib_1.default.connect(this.config.rabbitmqUrl);
        this.channel = await this.connection.createChannel();
        await this.channel.assertQueue(this.queueName, { durable: true });
        // Limit the consumer to processing one message at a time
        await this.channel.prefetch(1);
        console.log("RabbitMQ channel and queue initialized.");
        return this.channel;
    }
    async publishTask(task) {
        if (!this.channel) {
            throw new Error("RabbitMQ channel not initialized");
        }
        this.channel.sendToQueue(this.queueName, Buffer.from(JSON.stringify(task)), {
            persistent: true,
        });
        return `Published task ${task.id} to RabbitMQ.`;
    }
    async consumeTasks(onMessage) {
        if (!this.channel) {
            throw new Error("RabbitMQ channel not initialized");
        }
        this.channel.consume(this.queueName, async (msg) => {
            if (msg !== null) {
                try {
                    await onMessage(msg);
                    this.channel.ack(msg);
                }
                catch (error) {
                    console.error("Error processing message:", error);
                    this.channel.nack(msg, false, false);
                }
            }
        }, { noAck: false });
    }
}
exports.RabbitMQService = RabbitMQService;
